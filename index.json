[{"categories":null,"contents":"22년도에 작성했던, 일반인을 위한 쿠버네티스 소개글입니다\u0026hellip; 배운지 몇달 안 된 상태에서 썼던 글이라 각종 (이상한) 추상적인 표현이 많습니다.\n안녕하세요. 좋은 기회를 통해 최근 공부하고 있는 IT 기술인 쿠버네티스에 대해 소개 해드리고자 합니다.\n쿠버네티스? 최근 NHN사의 클라우드 교육을 다녀왔었습니다. 클라우드는 이제 많은 사람이 쉽고 편하게 사용하는 기술이지요? 매킨토시를 쓰거나, 윈도우를 쓸 때 icloud, OneDrive등의 기능을 쓰시는 분이 많을테고, 구글에서도 구글 드라이브에 자료를 저장하는 등의 경험이 있으실 것 같습니다. 그런 클라우드 시장에서 주목하는 기술 중 하나가 쿠버네티스 입니다.\n쿠버네티스에 대해 처음 들으시는 분들이 계실 것 같습니다. 저도 몇 달 전만 하더라도 일전에 한 번도 들어본 적 없는 이름이었습니다. 그래서 일까요? 왠지 신기술 처럼 느껴졌었네요. 하지만 쿠버네티스가 유명해 진 것이 최근이라고 하더라도 따끈따끈한 존재라기엔 나이가 꽤나 있습니다. 무려 8년 전인 2014년에 등장한 존재이지요. 구글과 리눅스 재단이 설립한 CNCF(Cloud Native Computing Foundation)에서 공식으로 쿠버네티스를 오픈소스화 하였습니다. 지금까지 지속적으로 업데이트 되고 있구요. 이미 기술적으로 성숙화 단계에 있다고들 하네요.\n쿠버네티스는 \u0026lsquo;가상화\u0026rsquo;나 \u0026lsquo;컨테이너\u0026rsquo; 혹은 \u0026lsquo;도커\u0026rsquo;와 \u0026lsquo;MSA(마이크로서비스 아키텍쳐)\u0026rsquo; 등의 키워드와 아주 밀접한 관계에 있습니다. 그렇기에 클라우드 환경과 아주 어울리는 기술이 되고 많은 이들의 주요한 관심을 끌고 있지요. 현재 클라우드 환경과 마이크로서비스 아키텍쳐가 가지는 장점과 매력은 세간에서 각광받는 키워드 일 것 같습니다. 아마 여러분 중에서도 마이크로서비스 아키텍쳐에 대해 이미 들어보신 분도 있을테고 실제로 활용해보신 분도 계실 것 같습니다. MSA를 채택한 가장 유명한 회사로 넷플릭스가 있습니다.\n혹시, 위에 언급된 여러 키워드 중에, 얼핏 들어보았는데 생소하거나 아니면 무슨 이야기를 하려는 지 전혀 감이 오지 않으시는 분 있으실까요? 정말 다행이네요. 이 글은 쿠버네티스를 처음 들어보시는 분들을 위해 약간의 도움을 드리고자 작성되었습니다. 한 번쯤 스쳐 지나가면서 보면 좋겠다 싶은 느낌으로요! (솔직히 쿠버네티스를 접한지 얼마되지 않았기 때문에 아주 깊은 수준의 기술을 설명해드릴 자신이 없네요 😅 )\n쿠버네티스에 대해 처음 들어보시는 분들께 제가 알고 있는 한에서 최대한 쉽게, 무엇을 위한 기술인지 설명 드리고자 합니다. 또한 어떤 이유로 쿠버네티스를 공부하고 있는지, 이것으로 뭘하고 있는지, 뭘 하려고 하는지 설명드릴 수 있는 기회가 되었으면 좋겠습니다.\n천천히 개념 접근하기 우선 쿠버네티스라는 말 자체와 친해져볼까요? Kubernetes란 명칭은 키잡이(helmsman)나 파일럿을 뜻하는 그리스어입니다. IT 기술 용어치고는 꽤나 특이한 의미를 가지고 있네요. 일종의 상징이나 비유 같은 걸까요? 실제로 쿠버네티스 로고 이미지는 배에서 사용할 법한 키로 되어있습니다. 심지어 바다를 떠올리게 하는 푸른색으로 뒤덮혀있지요.\n우리는 배 위에서 키를 잡는 사람을 선장이라 부릅니다. 선장은 바다 위를 누비며 자신을 따르는 선원들을 지휘하고 관리합니다. 영화 캐리비안의 해적에서 잭 스패로우가 그랬듯이요. 선장은 간단한 표현으로 배 위의 모든 것을 운영을 하는 사람입니다. 쿠버네티스의 로고가 \u0026lsquo;키\u0026rsquo;로 만들어진 이유가 바로 이것입니다. 모든 리더가 그러하듯, 키잡이(쿠버네티스)의 핵심적인 요소가 바로 \u0026lsquo;운영\u0026rsquo; 혹은 \u0026lsquo;관리\u0026rsquo;거 든요.\n구체적으로 무엇을 운영 혹은 관리 하는 것 일까요? 먼저 잭 스페로우가 뭘 했는지 부터 되새겨 봅시다.\n캐리비안의 해적 1편의 메인 소재였던 수많은 금화가 담긴 거대한 (저주 받은) 보물 상자를 기억하시나요? 잭 스패로우를 포함한 당대 해적, 그 중 선장들은 선원들을 부리며 단 하나의 목표에 사로 잡혀 있었습니다. 바로 보물을 찾아 영원한 명성과 부귀영화를 누리는 것 입니다. 보물 상자가 배 위에 올라온 순간 키잡이에게는 하나의 임무가 생깁니다. 육지까지 안전하게 보물을 운송하는 것입니다.\n위험의 요소는 참으로 많습니다. 다른 해적들에게서 지켜내는 게 최우선이구요. 또한 내부적으로 보물 상자를 훔쳐 달아나려는 선원도 관리해야 하고요. 또는 이외에 기이한 날씨 같이 기상천외한 현상으로부터 항해를 방해는 요소도 있었지요. 영화를 보면서 느낀 점이지만, 저런 환경에서는 참 살기 힘들었을 것 같아요.\n평화의 시대인 오늘날의 키잡이들은 상황이 좀 더 낫습니다. 과거보다 위험의 요소가 더 적다고 할까요? 단적으로 아래 사진처럼 모두가 탐내던 배 위의 귀중한 \u0026lsquo;보물 상자\u0026rsquo;는 수많은 \u0026lsquo;컨테이너 상자\u0026rsquo;로 대체 되었습니다. 여전히 바다 위로 선박을 노리는 해적들이 간간히 나타난다지만, 아주 극소수의 해프닝이 되었네요 (허나 무서운 일이지요). 저는 이분들 덕분에 아마존에서 주문한 해외 스타워즈 굿즈가 컨테이너 속에 담겨 안전하게 배송되어 너무나 행복합니다.\nIT기술을 설명한다면서 웬 뚱딴지 같은 이야기인가 싶으시겠지요? 너그러운 마음으로 이해를 돕기위한 긴 준비 단계였다고 생각해주세요. 사실은요, IT기술 쿠버네티스도 위의 예시들과 별반 다르지 않습니다.\n쿠버네티스는 컨테이너를 관리 운영하는 데 사용합니다. 그래서 컨테이너 오케스트레이션(Container Orchestration) 도구라고도 불리지요. 컴퓨터 세상에도 여러가지 위험요소 같은 것들이 많잖아요? 예를 들어 프로그램 켜놓고 까먹는다 던가, 필요한 파일을 필요할 때 못 찾는다던가 하는 느낌으로요. 컨테이너를 관리하는 데도 비슷한 일이 있는데요 …\n잠깐, 제가 아는 그 컨테이너가 맞아요? 아, 컨테이너가 뭔지부터 설명을 드려야 겠네요.\n위의 사진 같이 실생활 용품 가득 넣어진 화물 컨테이너를 생각하신다면, 아닙니다. 만약 그런거라면 쿠버네티스는 해운사에서 사용하는 프로그램쯤 되려나요? 😁\nIT 세계에서 언급되는 컨테이너는 하나의 \u0026lsquo;운영 체제 커널\u0026rsquo;에서 다른 프로세스에 영향을 받지 않고 \u0026lsquo;독립적으로 실행되는 프로세스\u0026rsquo; 상태를 의미 합니다. 제 표현이긴 하지만 컴퓨터 세상의 화물 컨테이너라고 해도 무관해보여요. 실제로 컨셉을 저기서 많이 따온 것 이구요.\n어떤 컨셉인지 화물 컨테이너와의 연관점으로 쉽게 이해해 봅시다. 우리가 사진으로 보듯 화물 컨테이너 외부는 다들 색깔만 다르지 비슷한 모양과 크기로 쌓여져 있습니다. 여러 화물 컨테이너가 같은 선박 위에 놓여있는 상황은 여러 인스턴스들이 \u0026lsquo;하나의 운영 체제 커널 위\u0026rsquo;에 있는 것과 비슷합니다.\n또, 중요한 것은 내부입니다. 화물 컨테이너 겉만 봐서는 내부에 어떤 물건이 놓여있는 지는 전혀 감을 잡을 수가 없습니다. 또 외부의 환경으로부터 대체로 분리되어 있고요. \u0026lsquo;독립적으로 실행되는 프로세스\u0026rsquo;라는 것이 바로 외부로 부터 지켜지는 \u0026lsquo;내부의 스타워즈 굿즈\u0026rsquo;와 같은 개념 입니다.\n정말 컴퓨터 세계에서 사용하는 화물 컨테이너라고 할 수 있겠죠? 다만, 내부에 좀 컴퓨터 적인 친구들을 담고 있을 뿐이죠. 가령 우분투나 센토스 같은 리눅스 운영체제 이미지 같은 거 말이에요. 컨테이너를 실행(컴퓨터 세상이다보니까 운송하는 대신 실행합니다)하는 외부의 환경이 윈도우 운영체제라도 문제 없습니다. 내부의 물건은 외부로부터 지켜지고 있거든요!\n컨테이너 기술은 가상 머신(Virtual Machine)과 많이 비교되곤 합니다. 둘의 공통점은 가상화 기술을 사용한다는 것 입니다. 가상화는 단일한 물리 하드웨어 시스템에서 여러 시뮬레이션 환경이나 전용 리소스를 생성할 수 있는 기술입니다. 구체적인 건 몰라도, 컨테이너 기술은 가상 머신에 비해 무척 가볍게 실행 됩니다. 가상 머신에서는 하이퍼바이저라는 것을 이용해 새로운 운영체제를 실행해야 하는데, 컨테이너는 그럴 필요가 없습니다. 그렇기에 똑같은 우분투 버전을 설치한다고 했을 때 용량 측면에서도, 실행 속도 측면에서도 꽤나 비교됩니다.\n컨테이너를 활용하는 경우에 대한 예제를 설명 드려볼까요? 저는 학창 시절에 \u0026lsquo;포트란\u0026rsquo;이라는 프로그래밍 언어를 사용했습니다. 포트란의 컴파일러 중 하나인 gfortran은 리눅스 환경에서는 무료로 쉽게 설치가 가능합니다. 하지만 리눅스에 대해 일도 몰랐던 저는 처음엔 윈도우 환경에서 포트란을 사용하고자 했었죠. 하지만 곧 마음을 바꿔 먹어야 했습니다. 윈도우에서 포트란을 사용하는 방법이 아예 없던 것은 아니지만, 리눅스 환경보다는 설치가 좀 더 어려웠고, 무료버전 컴파일러가 깔끔하지도 않았거든요. 저는 결국 리눅스와 친해지기로 결심하고 우분투를 컴퓨터에 설치했는데요. 은행 업무나 아래한글 프로그램 같은 것을 활용하기에 참 힘든 환경이었기에 꽤나 고생했던 기억이 납니다. 그런데 지금와서 생각해보면 쉽게 해결될 문제였습니다. 윈도우 운영체제 위에서 컨테이너 기술을 활용해 리눅스를 구동시켰다면 말이에요. (질문 - 컨테이너를 VM 처럼 써도 되는 걸 까요?)\n또 다른 예시는 데이터베이스 설치입니다. 데이터베이스도 컨테이너 환경으로 쉽게 구동 할 수 있습니다. 사용하지 않을 때는 컨테이너를 내려 마치 컴퓨터에 없는 존재처럼 만들 수도 있지요. 아까 컨테이너 내부는 외부로부터 지켜진다고 하였는데, 실제로 기본적인 설정으로는(네트워크 설정을 따로 해주지 않으면) 외부에서 컨테이너 내부로 통신할 방법이 없습니다. 컨테이너 내부에 독자적인 가상 네트워크만이 설정되기 때문이죠. 그럼 데이터베이스를 사용할 방법이 없게 느껴지시겠지만, 이제 쿠버네티스(혹은 도커)가 이런 부분을 해결해 줄 수 있습니다.\n도커? 쿠버네티스랑 같은 거에요? 도커랑 쿠버네티스는 다른 것입니다. 그러나 뗄 수 없는 사이 입니다.\nDocker라는 영단어는 사전적으로 항만 노동자라는 의미를 가지고 있습니다. 쿠버네티스와 비슷하게 바다를 연상케 하는 단어지요. 저는 위에서 여러번 컨테이너를 \u0026lsquo;실행\u0026rsquo;한다 라는 표현을 사용 했습니다. 도커라는 녀석은 이를 가능케 해주는 오픈 소스 프로젝트 입니다. 쿠버네티스를 사용하기 위해서는 도커와 같은 \u0026lsquo;컨테이너 런타임\u0026rsquo; 기술을 필요로 합니다.\n(정확하게는 도커와 쿠버네티스가 아니라, 컨테이너 런타임과 쿠버네티스는 뗄레야 뗄 수 없는 사이라고 해야겠습니다)\n로고를 한 번 보고 가시죠. 귀엽게 생긴 고래 배가 수 많은 컨테이너를 실고 물 위에 떠 있습니다. 그림이 암시하는 것처럼 사실 쿠버네티스 없이 도커만 있어도 컨테이너 한두 개를 운영하는 것은 문제가 되지 않습니다.\n허나, 도커가 출시된 해는 2013년이고 쿠버네티스보다 1년 정도 빠르게 등장한 기술입니다. 도커가 컨테이너 환경을 이용할 완벽한 기술이라면 쿠버네티스가 등장할 필요가 있었을까요? 쿠버네티스가 뒤늦게 등장했다는 것은 도커만으로 해결할 수 없는 문제가 있지 않을까라는 추론을 가능케 합니다. 네, 도커에는 중대한 문제가 있습니다. 한두 개가 아닌 수많은 컨테이너를 관리하기 힘들다라는 것 입니다.\n아마, 이런 생각을 하실 수 있으실 것 같습니다. 컨테이너를 그렇게 많이 구동 시킬 필요가 있나? 데이터베이스든 운영체제든 아무리 많이 필요하다고 해도 손가락으로 셀 수 있을 정도 아닐까? 이 질문에 대한 답이 바로 MSA(마이크로서비스 아키텍쳐)입니다.\n(다음에 계속)\n","date":"January 2, 2025","hero":"/images/hero/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4%EA%B0%80%20%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C.png","permalink":"https://kubesy.com/posts/500.-develop/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EA%B8%B0%EB%B3%B8/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4%EA%B0%80-%EB%AD%90%EC%A7%80/","summary":"\u003cp\u003e22년도에 작성했던, 일반인을 위한 쿠버네티스 소개글입니다\u0026hellip; 배운지 몇달 안 된 상태에서 썼던 글이라 각종 (이상한) 추상적인 표현이 많습니다.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e안녕하세요.\n좋은 기회를 통해 최근 공부하고 있는 IT 기술인 쿠버네티스에 대해 소개 해드리고자 합니다.\u003c/p\u003e\n\u003ch3 id=\"쿠버네티스\"\u003e쿠버네티스?\u003c/h3\u003e\n\u003cp\u003e최근 NHN사의 클라우드 교육을 다녀왔었습니다. 클라우드는 이제 많은 사람이 쉽고 편하게 사용하는 기술이지요? 매킨토시를 쓰거나, 윈도우를 쓸 때 icloud,  OneDrive등의 기능을 쓰시는 분이 많을테고, 구글에서도 구글 드라이브에 자료를 저장하는 등의 경험이 있으실 것 같습니다.  그런 클라우드 시장에서 주목하는 기술 중 하나가 쿠버네티스 입니다.\u003c/p\u003e","tags":null,"title":"쿠버네티스가 뭐지 1"},{"categories":null,"contents":"들어가기 앞서 \u0026hellip; 저는 비전공자 출신이고, 이제 곧 만 3년의 경력을 채우는 클라우드 도메인 쪽 개발자 입니다. ( 사실 개발자와 DevOps 엔지니어 그 어딘가에 걸쳐 있다고 생각하긴 하는데 \u0026hellip; )\n현재 제 주력 언어는, go와 python 인데요. 예전부터 java spring을 그래도 한 번은 경험 해봐야겠다는 생각을 가지고 있었습니다. (한국에서 백엔드는 자바 밖에 안 뽑아요 \u0026hellip;)\n그러다보니 스프링 부트 핵심 가이드 라는 책을 이전에 사놓고 방치해두고 있었다가, 연말 휴가를 맞이하여 한 번 도전해봐야겠다는 생각이 들었습니다.\n책을 내용을 기반으로 정리하되, 저만의 색깔을 덧입혀서 글을 써보려고 합니다. 아무쪼록 저와 비슷한 상태에 있는 독자 분들에게 도움이 되길 바랍니다.\n개념 자바 스프링 부트는 자바 스프링을 좀 더 쉽게 다룰 수 있게 합니다. 자바 스프링 만으로 프로젝트를 구축하려면, 아주 복잡한 설정들을 수행해야 하는데, 스프링 부트를 사용하면 이를 보다 약소화 할 수 있습니다.\nSpring 이라는 이름의 의미는, 개발자들에게 봄이 왔다는 뜻이라나 \u0026hellip;\n스프링의 가장 큰 특징은 의존성 주입 입니다. 스프링의 의존성 주입은 객체 간 결합도를 줄이고, 유연성과 테스트 가능성을 높이는 핵심 개념입니다. 이를 통해 스프링 애플리케이션은 더 관리하기 쉽고 확장 가능한 구조를 가지게 됩니다. 스프링의 DI는 현대적인 애플리케이션 설계에서 매우 중요한 역할을 합니다.\nDI는 \u0026ldquo;제어의 역전\u0026rdquo;(Inversion of Control, IoC) 원칙을 기반으로 합니다. 객체의 생성을 개발자가 직접 제어하지 않고, 스프링 컨테이너가 관리하도록 함으로써 코드의 유연성과 확장성을 보장합니다.\n결합도 감소\n객체 간의 의존 관계를 코드에서 직접 명시하지 않아 유연성이 높아집니다. 한 객체의 변경이 다른 객체에 미치는 영향을 최소화합니다. 테스트 용이성\nDI를 통해 의존성을 주입받으므로, 테스트 시에는 **모의 객체(Mock)**를 쉽게 주입할 수 있습니다. 유닛 테스트와 통합 테스트를 보다 쉽게 수행할 수 있습니다. 재사용성 증가\n객체가 특정 구현체에 의존하지 않으므로, 인터페이스나 추상 클래스만 정의하면 다양한 구현체를 주입받아 사용할 수 있습니다. 객체 생명주기 관리\n스프링 컨테이너가 객체의 생성, 초기화, 소멸까지 관리하므로 코드가 간결해지고 유지보수가 쉬워집니다. IoC 컨테이너는 애플리케이션의 객체(빈)를 생성하고, 의존 관계를 설정한 뒤 애플리케이션이 실행될 때 이를 제공합니다.\n처리 과정:\n빈(Bean) 정의 @Component, @Service, @Repository 등 애노테이션을 사용해 스프링이 관리할 빈을 정의합니다. 의존 관계 설정 @Autowired 또는 생성자를 통해 의존성을 정의합니다. 빈 생성 스프링 컨테이너가 애플리케이션 시작 시점에 빈을 생성하고 의존성을 주입합니다. DI 의 구현 방식은 크게 세 가지로 나뉩니다. 다만 대부분의 경우, 생성자 주입이 권장 됩니다.\n생성자 주입 @Component public class Service { private Repository repository; @Autowired public void setRepository(Repository repository) { this.repository = repository; } } Setter 주입 @Component public class Service { @Autowired private Repository repository; } 필드 주입 @Component public class Service { @Autowired private Repository repository; } DI 이외에도 AOP(Aspect-Oriented Programming 와 같은 특징이 있다고 합니다.\n사실 여기까지만 읽었을 때, 구체적인 구현을 보기 전까지는 조금 모호하다라는 생각이 듭니다. 또 Go를 제 첫 언어로 삼아서 그런지 자꾸 비교를 해가면서 이해하게 되는 양상이 있습니다. 예를 들어 MVC 와 같은 개념은 golang에서도 은연 중 사용하고 있었을 지 모르지만, 그다지 본격적으로 개념부터 알고 들어가진 않았어었습니다.\n아래의 그림을 보면, 데이터베이스 강의 앞 부분에서 보았던 개념과 매칭됩니다.\nGo 에서의 웹개발(gin-gonic)과, Java Spring Boot 를 통한 웹개발을 비교해가며 학습할 때, 개념적 접근의 차이가 느껴집니다. 예를들어 Java Spring Boot 에서 논하는 MVC 등이 Go를 사용할 때는 엄밀하게 따져가면서 개발하지 않았기 때문입니다. 사실 어느 정도는 비슷한 컨셉을 공유하고 있을 것 같은데, 이러한 차이는 어디서 오는 걸까요? Java (Spring Boot):\nJava는 객체지향 언어로 설계되어 있으며, 복잡한 비즈니스 로직을 계층화된 방식으로 구성하는 데 강점을 가집니다. Spring Boot는 엔터프라이즈 환경에서 확립된 MVC(Model-View-Controller) 패턴을 기반으로 한 구조를 강조하며, 컨벤션을 통해 개발을 간소화하려는 목적을 갖고 있습니다. 프레임워크 자체에서 DI(Dependency Injection), AOP(Aspect-Oriented Programming), 그리고 풍부한 어노테이션 지원 등을 제공해 복잡한 구조를 깔끔하게 관리하도록 돕습니다. Go (gin-gonic):\nGo는 최소주의(minimalism)를 기반으로 설계된 언어입니다. 코드가 단순하고 읽기 쉬우며, 복잡한 추상화보다는 실용적인 접근을 강조합니다. gin-gonic은 Go 언어의 철학을 따르는 경량 웹 프레임워크로, 불필요한 구조를 강요하지 않고, 개발자가 직접 필요한 패턴(MVC 포함)을 구성하도록 허용합니다. Go에서는 보통 \u0026ldquo;프로젝트 구조를 단순하게 유지\u0026quot;하는 것이 기본 철학에 가깝기 때문에, 엄격한 MVC 구조가 필요 없을 수도 있습니다. 위는 디자인 패턴 종류를 분류 해놓은 것 입니다. 스프링은 이중에 싱글톤 패턴, 팩토리 메서드, 프록시, 템플릿 메서드, 어댑터 등등의 다양한 원칙을 내재화 있다고 합니다.\n환경 구축 반골기질 때문에, 모두가 인텔리제이를 주장할 때 본인은 vscode를 고집하고 싶습니다. 그리고 패키지들을 무조건 최신에 가깝게 설정하고 싶어요 참고자료 https://it-ability.tistory.com/92 https://huimang2.github.io/etc/ubuntu-dev-env vscode 확장 프로그램 다운로드 Spring Boot Extension Pack Java Extension Pack JDK 설치 $ sudo dnf install java-17-openjdk java-17-openjdk-devel $ java --version openjdk 17.0.13 2024-10-15 LTS OpenJDK Runtime Environment (Red_Hat-17.0.13.0.11-1) (build 17.0.13+11-LTS) OpenJDK 64-Bit Server VM (Red_Hat-17.0.13.0.11-1) (build 17.0.13+11-LTS, mixed mode, sharing) $ readlink -f /usr/bin/java /usr/lib/jvm/java-17-openjdk-17.0.13.0.11-4.el9.x86_64/bin/java $ vi ~/.bashrc ... export JAVA_HOME=/usr/lib/jvm/java-17-openjdk export PATH=$PATH:$JAVA_HOME/bin ... $ source ~/.bashrc https://start.spring.io 에서 프로젝트 설정\nGenerate 후 폴더 압축 해제. -\u0026gt; vscode 에서 java projects 라는 ui에서 생성해도 됩니다. 참고로 위의 Package 네임으로 설정하면 문법 오류인가 봅니다.\nvscode settings.json 에 아래 와 같이 설정해줘서 자바 home 경로를 알 수 있게 해주어야 합니다.\n{ \u0026#34;java.jdt.ls.java.home\u0026#34;: \u0026#34;/usr/lib/jvm/java-17-openjdk\u0026#34; } 자 이제 생성된 코드 환경에서 몇 가지 구성을 확인해봅시다.\n첫 번째로 gradle 관련 항목입니다. 그 다음은 Spring Boot Dashboard 입니다. 현재 환경은 다른 프로세스에서 8080 포트를 사용하고 있습니다. 기본 시작 포트를 18080으로 바꿔봅니다.\nsrc/main/resources/application.properties 파일을 수정합니다.\nspring.application.name=demo server.port=18080 구동! src/main/java/com/example/demo/controller/DemoController.java 파일을 만들어서 아래처럼 코드를 추가 해줍니다.\npackage com.example.demo.controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class DemoController { @RequestMapping(\u0026#34;/demo\u0026#34;) public String hello() { return \u0026#34;Hello, World!\u0026#34;; } } 몇 가지 포인트를 찾아보면, 두 가지의 어노테이션을 임포트하였고, /demo라는 경로로 들어가는 경우 Hello, World! 를 리턴해주는 정말 간단한 로직입니다.\n솔직하게, import org.springframework.web.bind.annotation.RequestMapping; 등을 써야한다는 사실 자체 처음 알았고, 그 내부 로직이 무엇인지는 모릅니다. 그저 예제를 따라했을 뿐인데요.\n이러한 요소들을 파악하고, 좀 더 깊게 들어가면 기능의 구체적 구현 방식까지도 확인하는 그런 과정이 스프링을 이해하는 과정이 아닐까 싶은 생각이 들었습니다.\n","date":"December 24, 2024","hero":"/images/hero/spring%20boot.png","permalink":"https://kubesy.com/posts/300.-study/303.-java-spring-boot-/1.-%EA%B0%9C%EB%85%90-%EB%B0%8F-%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%B6%95-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EA%B0%84%EB%8B%A8%ED%95%9C-%EA%B5%AC%EB%8F%99/","summary":"\u003ch3 id=\"들어가기-앞서-font\"\u003e들어가기 앞서 \u0026hellip;\u003c/font\u003e\u003c/h3\u003e\n\u003cp\u003e저는 비전공자 출신이고, 이제 곧 만 3년의 경력을 채우는 클라우드 도메인 쪽 개발자 입니다. ( 사실 개발자와 DevOps 엔지니어 그 어딘가에 걸쳐 있다고 생각하긴 하는데 \u0026hellip; )\u003c/p\u003e\n\u003cp\u003e현재 제 주력 언어는, go와 python 인데요. 예전부터 java spring을 그래도 한 번은 경험 해봐야겠다는 생각을 가지고 있었습니다. (한국에서 백엔드는 자바 밖에 안 뽑아요 \u0026hellip;)\u003c/p\u003e\n\u003cp\u003e그러다보니 \u003ccode\u003e스프링 부트 핵심 가이드\u003c/code\u003e 라는 책을 이전에 사놓고 방치해두고 있었다가, 연말 휴가를 맞이하여 한 번 도전해봐야겠다는 생각이 들었습니다.\u003c/p\u003e","tags":null,"title":"1. 개념 및 환경 구축 그리고 간단한 구동"}]